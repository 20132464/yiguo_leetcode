对于整数 i, j，如果i+j可被60整除，则存在如下的等价关系：
(i+j)/60 等价于 (i%60 + j%60) == 60
这样我们就可以将任意值的整数a和b限制在0~59之间，因为它们的余数不会超过59。
因此，我们可以建立一个长度是60的数组rem，下标059对应059的余数，每个元素的值记录出现该余数的歌曲的数量。
我们对数组time进行遍历，对于每一个歌曲时长i：
1. 计算出与60余运算后的余数index = i%60;
2. 这样如果rem[60-index]不为空，那么里面记录的每一个歌曲总时长都可以和i相加后得到的总持续时间都能被60整除；
注意我们要考虑一种特殊情况：
当i可以被60整除时，index是0，那么这时候我们期望找到其他的可以被60整除的歌曲时长，就依然是rem[0]，所以我们将60-index要写成(60-index)%60;
3. 最后我们还要将当前歌曲记录到rem中的对应位置，以使得后续的歌曲可以与之配对。
--------------------------------
def numPairsDivisibleBy60(self, time):
        """
        :type time: List[int]
        :rtype: int
        """
        res = [0] * 60
        count = 0
        for i in time:
            index = i % 60
            count += res[(60 - index) % 60]
            res[index] += 1
        return count
---------------------------------
